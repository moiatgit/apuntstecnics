<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Apunts tècnics: Polimorfisme</title>
<meta name="description" content="">
<meta name="author" content="Moisès Gómez Girón">

<!-- HTML5 shim, for IE6-8 support of HTML elements -->
<!--[if lt IE 9]>
        <script src="./theme/html5.js"></script>
    <![endif]-->

<!-- Styles -->
<link href="./theme/bootstrap.moi.css" rel="stylesheet">
<link href="./theme/local.css" rel="stylesheet">
<link href="./theme/pygments.css" rel="stylesheet">

<!-- Feeds -->
<link href="http://apuntstecnics.herokuapp.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Apunts tècnics Atom Feed" />

</head>
<body>

<div class="topbar">
    <div class="topbar-inner">
        <div class="container-fluid">
            <a class="brand" href="./">[Apunts tècnics]
 Polimorfisme             </a>
        </div>
    </div>
</div>

<div class="container-fluid">
    <div class="sidebar">
        <div class="well">
            <!--
            <h3>Temes</h3>
                <ul>
                </ul>
            -->
            <h3>Categories</h3>
            <ul>
                <li ><a href="./category/dev.html">dev</a></li>
                <li ><a href="./category/eines.html">eines</a></li>
                <li ><a href="./category/gui.html">gui</a></li>
                <li ><a href="./category/misc.html">misc</a></li>
                <li class="active"><a href="./category/poo.html">poo</a></li>
                <li ><a href="./category/programacio.html">programacio</a></li>
                <li ><a href="./category/uml.html">uml</a></li>
            </ul>
            <h3>Tags</h3>
            <ul>
                <li><a href="./tag/test.html">test</a></li>
                <li><a href="./tag/programari.html">programari</a></li>
                <li><a href="./tag/c.html">C</a></li>
                <li><a href="./tag/java.html">java</a></li>
                <li><a href="./tag/util.html">util</a></li>
            </ul>
        </div>
    </div>

    <div class="content">
<div class='article'>
<div class="well small">
<ul id="navigation"> 
    <li class="navigation-prev">
    <a href="./constructors-part-ii.html">
        Constructors (part II)
    </a>
    </li>

    <li class="navigation-top">
    <a href="./un-primer-contacte-amb-la-programacio-en-java.html">
        inici
    </a>
    </li>

    <li class="navigation-next">
    <a href="./paquets-i-empaquetats.html">
        Paquets i empaquetats
    </a>
    </li>
</ul> 
</div>
    <div class="page-header"><h1>Polimorfisme</h1></div>
<div class="well small">
    Entrada ubicada a la categoria
    <a href="./category/poo.html">
        poo
    </a>
            amb el tag:
            <a href="./tag/java.html">java</a> 
</div>
    <div><div class="section" id="introduccio">
<h2>Introducció</h2>
<p>Aquest document introdueix al concepte de <em>polimorfisme</em>. Es tracta
d'una de les conseqüències més útils de l'herència i altres relacions
jeràrquiques.</p>
</div>
<div class="section" id="id1">
<h2>Polimorfisme</h2>
<div class="section" id="definicio">
<h3>Definició</h3>
<p>Una possible definició del polimorfisme és: possibilitat que
ofereixen alguns llenguatges de programació de fer servir dades de
diferents tipus d'una manera uniforme.</p>
<p>De les diferents &quot;varietats&quot; de polimorfisme que els teòrics
discuteixen, en aquest context ens és útil considerar:</p>
<ol class="arabic">
<li><p class="first"><em>polimorfisme de funcions</em>: mètodes que poden ser aplicats a diferents
tipus d'arguments. És el que aconseguim, per exemple, amb la
sobrecàrrega de mètodes en Java. Ex.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">m</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span> <span class="err">«</span><span class="o">...</span><span class="err">»</span> <span class="o">}</span>     <span class="c1">// versió amb enter</span>
    <span class="kt">void</span> <span class="nf">m</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span> <span class="err">«</span><span class="o">...</span><span class="err">»</span> <span class="o">}</span>    <span class="c1">// versió amb caràcter</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">m</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>       <span class="c1">// usa la versió amb enter</span>
        <span class="n">m</span><span class="o">(</span><span class="sc">&#39;1&#39;</span><span class="o">);</span>     <span class="c1">// usa la versió amb caràcter</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></li>
<li><p class="first"><em>polimòrfisme de subclasses</em>: una variable declarada d'una
determinada classe A, pot fer referència a instàncies de la classe
A, però també de qualsevol classe B que tingui a A com a
avantpassat <a class="footnote-reference" href="#avantpassat" id="id2">[1]</a>. Ex.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span> <span class="err">«</span><span class="o">...</span><span class="err">»</span> <span class="o">}</span>
<span class="kd">class</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="n">A</span> <span class="o">{</span> <span class="err">«</span><span class="o">...</span><span class="err">»</span> <span class="o">}</span>
<span class="kd">class</span> <span class="nc">C</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">A</span> <span class="n">a</span><span class="o">;</span>            <span class="c1">// referència de tipus A</span>
        <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="o">();</span>    <span class="c1">// instància de tipus A</span>
        <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">B</span><span class="o">();</span>    <span class="c1">// instància de tipus B assignada a una referència de tipus A</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></li>
</ol>
</div>
<div class="section" id="b-es-un-a-pero-a-no-es-un-b">
<h3>B és un A però A no és un B</h3>
<p>EL polimorfisme de subclasses ens permet fer servir una variable de
la superclasse per referenciar una instància de la subclasse, però
<strong>no</strong> a l'inrevés.</p>
<p>El següent dibuix intenta mostrar-ho gràficament.</p>
<div class="figure align-center">
<img alt="Metàfora dels cucurutxos" src="./images/poo013.img001.cucurutxos.png" />
</div>
<p>A la imatge veiem com un suport (<em>variable</em>) per cucurutxos de tipus
(<em>classe</em>) A, pot subjectar (<em>referenciar</em>) cucurutxos (<em>instàncies</em>) de
tipus A. Aquest mateix suport, és capaç de subjectar cucurutxos que
estenen el tipus A. En canvi, amb el suport pels cucurutxos de tipus
B, els de tipus A ens <strong>caurien</strong> a terra!</p>
</div>
<div class="section" id="assignacio-tardana">
<h3>Assignació tardana</h3>
<p>L'<em>assignació tardana</em> (o <em>late binding</em>) és la determinació del tipus
de dades/mètode que realment s'executarà és realitza en temps
d'execució i no en la compilació.</p>
<p>Per exemple, considerem:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
     <span class="kt">void</span> <span class="nf">m</span><span class="o">()</span> <span class="o">{</span> <span class="err">«</span><span class="o">...</span><span class="err">»</span> <span class="o">}</span>
 <span class="o">}</span>
 <span class="kd">class</span> <span class="nc">C</span> <span class="o">{</span>
     <span class="kt">void</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span>
         <span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="o">();</span>
         <span class="n">a</span><span class="o">.</span><span class="na">m</span><span class="o">();</span>
     <span class="o">}</span>
 <span class="o">}</span>
</pre></div>
</td></tr></table><p>El codi que finalment es cridarà en la línia 7 sembla que podria ser
determinat en temps de compilació: no hauria de ser el definit pel
mètode <tt class="docutils literal">A.m()</tt>?. En canvi:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
     <span class="kt">void</span> <span class="nf">m</span><span class="o">()</span> <span class="o">{</span> <span class="err">«</span><span class="o">...</span><span class="err">»</span> <span class="o">}</span>
 <span class="o">}</span>
 <span class="kd">class</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="n">A</span> <span class="o">{</span>
     <span class="kt">void</span> <span class="nf">m</span><span class="o">()</span> <span class="o">{</span> <span class="err">«</span><span class="o">...</span><span class="err">»</span> <span class="o">}</span> <span class="c1">// redefinició de m()</span>
     <span class="kt">void</span> <span class="nf">n</span><span class="o">()</span> <span class="o">{</span> <span class="err">«</span><span class="o">...</span><span class="err">»</span> <span class="o">}</span> <span class="c1">// un altre mètode</span>
 <span class="o">}</span>
 <span class="kd">class</span> <span class="nc">C</span> <span class="o">{</span>
     <span class="kt">void</span> <span class="nf">f</span><span class="o">(</span><span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">a</span><span class="o">.</span><span class="na">m</span><span class="o">();</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="k">instanceof</span> <span class="n">B</span><span class="o">)</span> <span class="o">{</span>   <span class="c1">// comprova si a és instància de B</span>
             <span class="n">B</span> <span class="n">b</span> <span class="o">=</span> <span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="n">a</span><span class="o">;</span>         <span class="c1">// considera a com un B</span>
             <span class="n">b</span><span class="o">.</span><span class="na">n</span><span class="o">();</span>              <span class="c1">// ara ja puc accedir a B.n()</span>
             <span class="o">((</span><span class="n">B</span><span class="o">)</span><span class="n">a</span><span class="o">).</span><span class="na">n</span><span class="o">();</span>         <span class="c1">// també ho puc fer directament</span>
         <span class="o">}</span>
     <span class="o">}</span>
     <span class="kt">void</span> <span class="nf">g</span><span class="o">()</span> <span class="o">{</span>
         <span class="n">f</span><span class="o">(</span><span class="k">new</span> <span class="n">A</span><span class="o">());</span>
         <span class="n">f</span><span class="o">(</span><span class="k">new</span> <span class="n">B</span><span class="o">());</span>
     <span class="o">}</span>
 <span class="o">}</span>
</pre></div>
</td></tr></table><p>En aquest segon exemple, la situació no està tan clara. Quin mètode
s'executarà a la línia 10? El del mètode definit a la línia 2 o el de
la 5?</p>
<p>El compilador no té manera de saber-ho, així que serà la màquina
virtual qui ho determinarà, en funció del tipus de la instància que
finalment estigui rebent <tt class="docutils literal">C.f(A)</tt>.</p>
<p>A la línia 11 fem servir l'operador <em>instanceof</em>. Aquest operador ens
retornarà True si, en temps d'execució, el primer operand resulta ser
una instància del tipus del segon operand (o bé d'una subclasse
d'aquest) <a class="footnote-reference" href="#instanceof" id="id3">[3]</a>.</p>
<p>Sovint <em>late binding</em> es traduït també per <em>assignació dinàmica</em>, per
contrapossar-ho a l'<em>assignació estàtica</em> que oferiria el compilador
(si pogués).</p>
<p>Per cert, aquesta flexibilitat té un preu: es paga amb la velocitat
d'execució. Si estàs desenvolupant un codi on l'eficiència sigui
crítica i saps que un mètode no serà redefinit per una subclasse, pots
facilitar la feina al compilador fent servir <tt class="docutils literal">final</tt>:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
     <span class="kd">final</span> <span class="kt">void</span> <span class="nf">m</span><span class="o">()</span> <span class="o">{</span> <span class="err">«</span><span class="o">...</span><span class="err">»</span> <span class="o">}</span>
 <span class="o">}</span>
 <span class="kd">class</span> <span class="nc">C</span> <span class="o">{</span>
     <span class="kt">void</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span>
         <span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="o">();</span>
         <span class="n">a</span><span class="o">.</span><span class="na">m</span><span class="o">();</span>
     <span class="o">}</span>
 <span class="o">}</span>
</pre></div>
</td></tr></table><p>Amb aquest darrer exemple, el compilador <em>sí</em> sap quin serà el codi
que s'executarà. Això sí, no intentis crear una subclasse B com la de
fa dos exemples perquè el compilador es queixarà!</p>
</div>
<div class="section" id="si-pero-quin-metode-es-crida">
<h3>Sí però... quin mètode es crida</h3>
<p>Quan ens enfrontem per primer cop al polimorfisme, una de les
dificultats més grans és saber com es realitza finalment aquesta
assignació tardana.</p>
<p>Per exemple:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight"><pre> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
     <span class="kt">void</span> <span class="nf">m</span><span class="o">()</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;superclasse&quot;</span><span class="o">);</span> <span class="o">}</span>
 <span class="o">}</span>

 <span class="kd">class</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="n">A</span> <span class="o">{</span>
     <span class="kt">void</span> <span class="nf">m</span><span class="o">()</span>  <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;subclasse&quot;</span><span class="o">);</span> <span class="o">}</span>
     <span class="kt">void</span> <span class="nf">sm</span><span class="o">()</span> <span class="o">{</span> <span class="kd">super</span><span class="o">.</span><span class="na">m</span><span class="o">();</span> <span class="o">}</span> <span class="c1">// una mena d&#39;àlies de A.m()</span>
 <span class="o">}</span>

 <span class="kd">class</span> <span class="nc">C</span> <span class="o">{</span>
     <span class="kt">void</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span>
         <span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="o">();</span>
         <span class="n">a</span><span class="o">.</span><span class="na">m</span><span class="o">();</span>       <span class="c1">// escriu: superclasse</span>
         <span class="n">B</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">B</span><span class="o">();</span>
         <span class="n">b</span><span class="o">.</span><span class="na">m</span><span class="o">();</span>       <span class="c1">// escriu: subclasse</span>
         <span class="o">((</span><span class="n">A</span><span class="o">)</span><span class="n">b</span><span class="o">).</span><span class="na">m</span><span class="o">();</span>  <span class="c1">// escriu... subclasse!</span>
         <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">B</span><span class="o">();</span>
         <span class="n">a</span><span class="o">.</span><span class="na">m</span><span class="o">();</span>       <span class="c1">// escriu... subclasse!</span>
         <span class="n">b</span><span class="o">.</span><span class="na">sm</span><span class="o">();</span>      <span class="c1">// escriu: superclasse</span>

         <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="o">();</span> <span class="c1">// error de compilació</span>
         <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="o">();</span>
         <span class="n">a</span><span class="o">.</span><span class="na">sm</span><span class="o">();</span>      <span class="c1">// error de compilació</span>
         <span class="o">((</span><span class="n">B</span><span class="o">)</span><span class="n">a</span><span class="o">).</span><span class="na">sm</span><span class="o">();</span> <span class="c1">// error d&#39;execució</span>
     <span class="o">}</span>
 <span class="o">}</span>
</pre></div>
</td></tr></table><p>En l'exemple veiem que a la màquina virtual no hi ha manera de fer-li
executar el mètode definit per A des d'una instància de B (excepte
fent servir l'&quot;<em>àlies</em>&quot; <tt class="docutils literal">B.sm()</tt>.</p>
<p>L'exemple afegeix, a mode de repàs, alguns errors típics dels que
s'inicien amb aquests temes.</p>
</div>
<div class="section" id="liskov">
<h3>Liskov</h3>
<p>El principi de substitució de <a class="reference external" href="http://en.wikipedia.org/wiki/Barbara_Jane_Liskov">Liskov</a> diu que:</p>
<blockquote>
una herència entre dues classes està correctament definida si
<strong>sempre</strong> es pot fer servir una instància de la subclasse allà on
el programa espera una instància de la superclasse.</blockquote>
<p>Un exemple típic d'herència incorrecta <a class="footnote-reference" href="#herenciaincorrecta" id="id5">[2]</a> és entre
Quadrat i Rectangle (o també Cercle i Oval). Suposa que tens les
següents classes:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre> <span class="kd">class</span> <span class="nc">Rectangle</span> <span class="o">{</span>
     <span class="kd">private</span> <span class="kt">int</span> <span class="n">base</span><span class="o">,</span> <span class="n">altura</span><span class="o">;</span>
     <span class="kd">public</span> <span class="nf">Rectangle</span><span class="o">(</span><span class="kt">int</span> <span class="n">base</span><span class="o">,</span> <span class="kt">int</span> <span class="n">altura</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">this</span><span class="o">.</span><span class="na">base</span> <span class="o">=</span> <span class="n">base</span><span class="o">;</span> <span class="k">this</span><span class="o">.</span><span class="na">altura</span> <span class="o">=</span> <span class="n">altura</span><span class="o">;</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getBase</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">base</span><span class="o">;</span> <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAltura</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">altura</span><span class="o">;</span> <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setBase</span><span class="o">(</span><span class="kt">int</span> <span class="n">base</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">base</span><span class="o">=</span><span class="n">base</span><span class="o">;</span> <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAltura</span><span class="o">(</span><span class="kt">int</span> <span class="n">base</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">altura</span><span class="o">=</span><span class="n">altura</span><span class="o">;</span> <span class="o">}</span>
     <span class="err">«</span><span class="o">...</span><span class="err">»</span>
 <span class="o">}</span>

 <span class="kd">class</span> <span class="nc">Quadrat</span> <span class="kd">extends</span> <span class="n">Rectangle</span> <span class="o">{</span>
     <span class="kd">public</span> <span class="nf">Quadrat</span><span class="o">(</span><span class="kt">int</span> <span class="n">costat</span><span class="o">)</span> <span class="o">{</span>
         <span class="kd">super</span><span class="o">(</span><span class="n">costat</span><span class="o">,</span> <span class="n">costat</span><span class="o">);</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCostat</span><span class="o">()</span> <span class="o">{</span> <span class="n">getBase</span><span class="o">();</span> <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setCostat</span><span class="o">(</span><span class="kt">int</span> <span class="n">costat</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">setBase</span><span class="o">(</span><span class="n">costat</span><span class="o">);</span>
         <span class="n">setAltura</span><span class="o">(</span><span class="n">costat</span><span class="o">);</span>
     <span class="o">}</span>
     <span class="err">«</span><span class="o">...</span><span class="err">»</span>
 <span class="o">}</span>
</pre></div>
</td></tr></table><p>Malgrat que, en principi, una herència com aquesta pot semblar una
bona idea (especialment si els «...» inclouen molt de codi, en
realitat amaga una desagradable sorpresa. Considera el següent codi:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre> <span class="kd">class</span> <span class="nc">UsaRectangles</span> <span class="o">{</span>
     <span class="kt">void</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span>
         <span class="n">Rectangle</span><span class="o">[]</span> <span class="n">rectangles</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rectangle</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
         <span class="n">rectangles</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rectangle</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
         <span class="n">rectangles</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Quadrat</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
         <span class="k">for</span> <span class="o">(</span><span class="n">Rectangle</span> <span class="nl">r:</span> <span class="n">rectangles</span><span class="o">)</span> <span class="o">{</span>
             <span class="n">r</span><span class="o">.</span><span class="na">setBase</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="na">getBase</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// encongeix la base</span>
         <span class="o">}</span>
     <span class="o">}</span>
 <span class="o">}</span>
</pre></div>
</td></tr></table><p>En <tt class="docutils literal">UsaRectangles.f()</tt> aconseguim que la instància de Quadrat
referenciada per <tt class="docutils literal">rectangles[1]</tt> acabi tenint un quadrat de costat 3
i 4!. És a dir, hem aconseguit <em>petar</em> la coherència de la classe i
tot fent-la servir &quot;legalment&quot;.</p>
<p>El problema de l'exemple és que un quadrat <strong>no</strong> es pot considerar un
rectangle en tots els contexts on s'espera que es comporti
correctament un rectangle (ex. quan encongim un dels seus costats)</p>
<p>En resum, abans de crear una subclasse B d'una classe A, assegurem-nos
que podem dir que tot B <strong>és un</strong> A. No n'hi ha prou amb que <em>algun</em> B
és un A, o tot B s'<em>assembla</em> a A, o <em>és pràcticament un</em> A <em>excepte
per</em>..., etc. Els <em>ornitorincs</em> en POO a la llarga es paguen cars. No
diguis després que no se t'ha avisa't!.</p>
</div>
</div>
<div class="section" id="exercici-1-analisi-d-errors-tipics">
<h2>Exercici 1. Anàlisi d'errors típics</h2>
<p>Torna a considerar el codi de l'exemple que apareix a la secció <a class="reference internal" href="#si-pero-quin-metode-es-crida">Sí
però... quin mètode es crida</a>.</p>
<p>Redacta un breu document en que expliquis el perquè de cada sortida o
error de les instruccions de la funció <tt class="docutils literal">C.f()</tt>.</p>
<p>Per exemple, per la línia 13 es podria dir:</p>
<blockquote>
Línia 13.  <tt class="docutils literal"><span class="pre">a.m();</span></tt> escriu <em>superclasse</em> perquè <tt class="docutils literal">a</tt> fa
referència a una instància de tipus <tt class="docutils literal">A</tt> i aquesta inclou el
mètode <tt class="docutils literal">void m()</tt>.</blockquote>
</div>
<div class="section" id="exercici-2-molts-gats">
<h2>Exercici 2. Molts gats</h2>
<p>Ja se sap, deixes entrar un gat a casa i aviat convida els seus
amics...</p>
<p>Modifiquem la classe Gat per què el seu constructor mostri el missatge
&quot;«nom»: he nascut!&quot; a menys que es crei com a silenciós.</p>
<p>Modifica el codi de la classe UsaGat que inclou l'exercici 1 dels
continguts d'<a class="reference external" href="./herencia.html">herència</a> de
manera que <em>main()</em> afegeixi sempre a Renat i a Garfield a la llista.
En crearà una instància de gat per cada nom que rebi per línia de
comandes. En cas que per la línia de comandes es demani al Renat o al
Garfield, indicarà amb un warning que aquests dos ja hi són a la
gàbia.</p>
</div>
<div class="section" id="exercici-3-l-entorn-operatiu-dels-gats">
<h2>Exercici 3. L'entorn operatiu dels gats</h2>
<p>Ara que tenim una quantitat considerable de gats, necessitem disposar
d'un sistema flexible per a poder-los &quot;manipular&quot;.</p>
<p>Així, crearem una nova versió de l'entorn operatiu dels Gats amb les
següents modificacions.</p>
<p>El <em>prompt</em> de l'entorn serà:</p>
<div class="highlight"><pre>[Gats]:
</pre></div>
<p>Les ordres que se li podran donar, seran:</p>
<div class="highlight"><pre>crea gat «nom»
mata gat «nom»
llista gats
«nom» com estàs?
«nom» aixeca’t
«nom» seu
«nom» estira&#39;t
«nom» miola
adéu
</pre></div>
<p>Substituirem, es clar «nom» pel nom del gat en qüestió.</p>
<p>Els missatges que generarà seran:</p>
<div class="highlight"><pre>Creat el gat «nom».
Ja existeix un gat amb el nom «nom».
Matat el gat «nom».
No hi ha cap gat amb el nom «nom».
Els gats de la llista són: «nom», «nom», ..., «nom».
No hi ha cap gat a la llista.
«nom» diu: estic dret.
«nom» diu: estic assegut.
«nom» diu: estic estirat.
«nom» diu: fet.
«nom» diu: ja estava dret.
«nom» diu: ja estava assegut.
«nom» diu: ja estava estirat.
No entenc el missatge.
Adéu.
</pre></div>
<p>Inicialment el programa afegirà automàticament una instància dels gats
Renat i Garfield a la llista de gats. Aquests podran ser eliminats com
qualsevol altre i no s'oferirà a l'usuari la possibilitat d'accedir a
membres de subclasse que no pertanyin a l'hora a la superclasse.</p>
<p><strong>Pista</strong>: en cas que tinguis problemes per extreure la informació de
l'entrada de l'usuari, et proposo que facis una ullada a <a class="reference external" href="./resources/ComandaText.java">aquest codi</a>. Estudia el mètode
<tt class="docutils literal">main()</tt> per entendre el seu funcionament.</p>
</div>
<div class="section" id="exercici-4-l-entorn-operatiu-dels-animals">
<h2>Exercici 4. L'entorn operatiu dels animals</h2>
<p>Els amics dels gats potser estaran satisfets amb l'entorn dels gats,
però, que em dius dels amics dels gossos?</p>
<p>En aquest problema, es demana implementar les classes Animal i Gos.</p>
<p>Els gossos, pel que respecta a aquest exercici, són molt semblants als
gats. Únicament no miolen. En canvi sí borden. Per aquesta raó, la
classe Animal disposarà del mètode <tt class="docutils literal">fesSoroll()</tt> que els Gats
implementaran cridant a <tt class="docutils literal">miola()</tt> i els gossos a <tt class="docutils literal">borda()</tt></p>
<p>Realitza els canvis que siguin necessaris a la classe Gat, de manera
que no calgui modificar cap de les seves subclasses ni cap dels
programes dels exercicis anteriors.</p>
<p>Finalment implementa un entorn operatiu d'animals, similar al dels
gats però que permeti explotar les funcionalitats que ofereixen els
animals.</p>
<p>El <em>prompt</em> de l'entorn serà: <tt class="docutils literal">[Animals]:</tt></p>
<p>Les ordres que se li podran donar, seran les mateixes que les de
l'exercici anterior, i a més:</p>
<div class="highlight"><pre>crea gos «nom»
mata gos «nom»
mata animal «nom»
llista gossos
llista animals
«nom» borda
«nom» fes soroll
</pre></div>
<p>Substituirem, es clar «nom» pel nom del gat en qüestió.</p>
<p>Els missatges que generarà seran:</p>
<div class="highlight"><pre>Creat el gos «nom».
Ja existeix un animal amb el nom «nom».
Matat el gos «nom».
No hi ha cap gos amb el nom «nom».
No hi ha cap animal amb el nom «nom».
Els gossos de la llista són: «nom», «nom», ..., «nom».
Els animals de la llista són: «nom», «nom», ..., «nom».
No hi ha cap gos a la llista.
No hi ha cap animal a la llista.
«nom» no és cap gat per miolar.
«nom» no és cap gos per bordar.
</pre></div>
<p>Inicialment no hi haurà cap animal a la llista.</p>
<p>Pista: tot i que pots fer servir l'operador <em>instanceof</em>, també pots
considerar fer servir tres llistes, una per gats, una altra per gos i
la tercera per animals en general. Si estàs preocupat per que això
pugui representar una duplicació d'informació, recorda que en realitat
d'un mateix gat només tindràs una instància, amb una referència a la
llista d'animals i una altra a la de gats.</p>
</div>
<hr class="docutils" />
<div class="section" id="notes">
<h2>Notes</h2>
<table class="docutils footnote" frame="void" id="avantpassat" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>(B és subclasse de A, o bé d'una classe C que tingui a A com a
avantpassat)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="herenciaincorrecta" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[2]</a></td><td>Sorprenentment, aquestes exemples els
trobarem a molts textos (i cursos) d'introducció a la programació
orientada a objectes, pel concepte d'herència!</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="instanceof" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>No tothom està gaire d'acord amb l'ús &quot;indiscriminat&quot;
del <em>instanceof</em>. Mira per exemple l'article <a class="reference external" href="http://www.javapractices.com/topic/TopicAction.do?Id=31">Beware of instanceof
operator</a></td></tr>
</tbody>
</table>
</div>
</div>
<div class="well small">
<ul id="navigation"> 
    <li class="navigation-prev">
    <a href="./constructors-part-ii.html">
        Constructors (part II)
    </a>
    </li>

    <li class="navigation-top">
    <a href="./un-primer-contacte-amb-la-programacio-en-java.html">
        inici
    </a>
    </li>

    <li class="navigation-next">
    <a href="./paquets-i-empaquetats.html">
        Paquets i empaquetats
    </a>
    </li>
</ul> 
</div>
</div>
<footer>
  <p>
  <a href=".">Apunts tècnics</a> 
  &copy; 
  <a href="http://www.gnu.org/copyleft/fdl.html">GNU FDL</a>
  per <i>Moisès Gómez Girón </i> (<img style="position:relative;top:+5px;border:0; display:inline;" src="./images/adressamoi.png">)
  amb el generador de blocs <a href="http://getpelican.com/">Pelican</a> 
  </p>
</footer>    </div>
</div>

</body>
</html>